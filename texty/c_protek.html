<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <META HTTP-EQUIV="Content-type" CONTENT="text/html; charset=iso-8859-2">
 <TITLE>borland pascal: z realu do protektu</TITLE>
</HEAD>
<BODY>
<PRE>
                       borland pascal:

                         z realu do protektu

   První  vìc,  kterou  èlovìk  vìt¹inou zkusí,  je  vzít  nìjaký  svùj
oblíbený  program  psaný  v  realu  a zkompilovat  ho  pro  protekt  (v
BP.EXE  je volba  real  /  protekt /  windows).  Kdy¾ nevzniknou  ¾ádné
syntaktické  chyby (to  by ani  myslím nemìly)  a program  se rozbìhne,
obvykle  záhy  skonèí  s  hlá¹kou  Runtime  Error  216  neboli  General
Protection  Fault  (GPF). Zklamaný  programátor  se  vrátí do  realu  a
¾ije ¹»astnì a¾ do smrti.

   Jak  to  bylo vlastnì  se  mnou...  stalo se  mi  to  taky ?  Drrrr,
drrrrr.. pamì» zvy¹uje  obrátky. Ááá, já vlastnì uva¾oval  jestli s tím
zapraseným  zdrojákem   Paøeni¹tì  seknu,  budu  pokraèovat   v  realu,
pøepí¹u ho  do Cèka  nebo do  protektu. První  vypadl real.  Potom jsem
musel ovìøit,  co to  vùbec ten  protekt je  a jestli  v nìm  mù¾e nìco
jako  Paøeni¹tì fungovat.  Kniha  Mikroprocesory Intel  Pentium a  spol
od  Grady   podobné  otázky   zodpoví  dost  dobøe,   doporuèuji.  Poté
zbývalo  prakticky ovìøit,  jak to  s tím  protektem v  Pascalu vlastnì
je. Dneska  mi u¾ pøijde  absurdní pøedstava,  ¾e jsem to  nevìdìl, ale
ono to  asi opravdu  nikde není napsané.  Výsledek prùzkumu  byl tento:
16bitový kód,  16bitová data (tj. xor ax,ax vynuluje  ax a db  66h; xor
ax,ax vynuluje eax, lodsb ète z  [si] a db 67h; lodsb z  [esi], v¹echno
pøesnì  jako  v  realu).  Najednou  to  vypadá,  ¾e  mezi  protektem  a
realem  v  Borland  Pascalu  není  ¾ádný  rozdíl  (kromì  detailù  jako
alokace pamìti).  Zkusím sepsat  na jaké  hlavní rozdíly  jsem postupnì
narazil.

Nejde zapisovat do CS.
- Dá se obejít i bez toho. Nìkdy to vypadá, ¾e ne, ale jde to.

Nejde zapisovat do $A000.
- Zato jde do SegA000 (dále SegB800, Seg0040, SegB000).

Nejde èíst ani zapisovat na adresy, které nejsou tvoje.
- Interrupty nastavovat slu¹nì.
- Dávat si pozor na konce polí apod.

Nejde  pracovat s  neplatnými pointery  (kromì nil),  jinak øeèeno,  do
segmentového registru nejde zapsat neplatný selektor.
- Dávat si pozor.
-  Kdy¾  je  to  nutné,  dá   se  s  neplatným  pointerem  pracovat  po
pøetypování  na  longint  (BP  pak nenahrává  segment  do  segmentového
registru).

Nejde v¹echnu pamì» alokovat pøes INT 21.
- Zkusit pou¾ívat pascalský GetMem.

Nejde alokovat souvislých 64KB a víc.
- U¾ jsem  o tom psal v  tricích, nejlep¹í je asi  pou¾ít GlobalAlloc z
unity WinAPI.

Nefungují  VESA  BIOS,  Get  ROM   font,  Event  wait  a  dal¹í  slu¾by
systému (já zatím narazil jen na tyto).
- Co  se stane kdy¾  napí¹e¹ INT  10h ? Nezapomeò  ¾e jsi v  protektu a
obsluha  INT 10h  je psaná  v  realu. Staèilo  by pøepnout  do realu  a
provést  pùvodní obsluhu  ?  Asi  ne.. :)  Rozdíl  je  mezi segmenty  a
selektory  (odkazuji  na Mikroprocesory  Intel..).  Kdy¾  má¹ slu¾bì  v
registrech  pøedat  pointer,  pøedá¹  selektor a  offset.  Ale  realová
obsluha  chce  segment a  offset.  I  kdybys  znal ke  svému  selektoru
pøíslu¹ný  segment, nemohl  bys  ho pøedat,  proto¾e  ten nejde  zapsat
do segmentového registru.
   Od  toho tu  je RTM.EXE.  Je¹tì  v protektu  zachytává interrupty  a
tam, kde  je to  tøeba, pøevádí  selektory na  segmenty. Stejnì  tak po
skonèení  slu¾by konvertuje  pøípadné  vrácené  segmenty na  selektory.
A  proto¾e vìt¹ina  tvých dat  le¾í nad  1MB, je¹tì  je musí  kopírovat
do  konvenèní pamìti  pod  1MB, pøípadnì  zpátky  (realová obsluha  nad
1MB nedosáhne).
   Vypadá  to  promakanì (ne  moc  rychlé,  ale  funkèní), tak  kde  je
problém  ?  RTM  musí  mít  pøehled  o  v¹ech  funkcích  systému.  Kdy¾
zavolá¹  tøeba INT  21  s  AX=3d00, RTM  musí  vìdìt,  ¾e tahle  slu¾ba
pracuje s  pointerem DS:DX  na blok  256(?) bajtù,  aby tìch  256 bajtù
z DS:DX  zkopèil do konvenèní pamìti  a do DS dal  segment. Jiná slu¾ba
mù¾e  mít  v   DS  tøeba  offset,  tak¾e   nejde  automaticky  pøevádìt
v¹echny segmentové registry.
   RTM  se  sna¾í,  ale  v¹echny  slu¾by  prostì  nemù¾e  znát,  zvlá¹»
kdy¾ vznikly  pozdìji ne¾ RTM.  A jsou tu  i jiné záludnosti.  Tøeba AT
slu¾ba Event  wait. Té pøedá¹  pointer na boolean a  poèet mikrosekund.
Slu¾ba  skonèí hned,  ale za  udanou  dobu boolean  nastaví. To  prostì
nejde.  Kdy¾  je  tvùj  boolean  nad 1MB  tak  nejde  zaøídit,  aby  ho
realmódová slu¾ba Event wait nastavila.
   Øe¹ení  tìchto problémù  existuje.  Jsou to  DPMI  slu¾by (INT  31).
Namátkou:  Alloc Dos  Mem,  Free Dos  Mem, SegmentDescriptor,  Simulate
Realmode  Interrupt  (dále  viz  interrupt  list).  Pomocí  nich  mù¾e¹
naalokovat  konvenèní pamì»  tak, ¾e  dostane¹ segment  i selektor.  Se
segmentem  se  bude¹  obracet   na  realmódové  slu¾by,  se  selektorem
bude¹ pracovat  sám. Alokovat konvenèní  pamì» jde  i v unitì  WinAPI a
obyèejným voláním INT 21, ale nejlep¹í zku¹enosti mám s DPMI.

Automaticky se nastavuje {$define dpmi} (v realu define msdos).

Nejde debugovat.
-  Externí   debugger  TDDPMI  sice   není  tak  cool   jako  'internal
debugging',  ale dá  se  s ním  pøekvapivì rychle  s¾ít.  Dokonce má  i
nìkteré výhody (oceòuji posmrtné prohlí¾ení lokálních promìnných).

Poèítaè se ménì hroutí.
-  Koneènì nìjaká  výhoda.  Tam kde  se v  realu  zhroutil teï  nejspí¹
hodí runtime error.

Offset první promìnné v DS je jiný.
-  V  realu   je  první  promìnná  v  datasegmentu  na   offsetu  2,  v
protektu 16.  To pro  pøípad, ¾e  bys chtìl mít  pole bajtù  takové, ¾e
index  prvku je  roven  jeho  offsetu (moc  fajn  vlastnost,  mám ji  v
Paøeni¹ti tak za¾ranou, ¾e se jí nemù¾u zbavit).

Nejde èíst/psát word na 0ffff apod (pøes hranici segmentu).
- Dávat pozor.
- Vlastnì by to  nemìlo jít ani v realu, ale vzpomínám  si, ¾e zrovna v
realu (ne ve V86) to nìjak pro¹lo.

Celá pamì» je pøímo pøístupná (¾ádné handlování s XMS,EMS).
- Da cool !


</PRE>
<p>
<a href="../dee">Dee</a>
</BODY>
</HTML>
