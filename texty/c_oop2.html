<!DOCTYPE HTML>
<HTML lang="cs">
<HEAD>
 <META charset="iso-8859-2">
 <TITLE>Objektovì Orientované Programování - V BORLAND PASCALU</TITLE>
</HEAD>
<BODY>
<PRE>
       Objektovì Orientované Programování - V BORLAND PASCALU

   V minulém  èísle vy¹el  èlánek o  OOP. Jako  dodatek k  nìmu pøipojuji
toto struèné zasvìcení do syntaxe OOP v Borland Pascalu.

   Sám  jsem zaèínal  hezky pomalouèku.  Krùèek po  krùèku. První  krùèek
u¾  má¹  urèitì za  sebou,  tak¾e  se  pøi  ètìní pøí¹tího  odstavce  nic
nového nedozví¹.  Ale postupnì  bys mìl  v èlánku dojít  a¾ k  místu, kde
narazí¹  na  nìjaké  nové  informace (kdybys  syntaxi  ovládal,  asi  bys
tohle neèet... leda ¾e bys hledal bugy :-).. zdravím cpoce, hi dood!).

                          _____ Object _____

   Vìdìl jsem,  ¾e existují  nìjaké objekty, vypadá  to jeko  record, ale
místo record  se pí¹e  object. Tak  jsem to zkusil  a v¹echno  se chovalo
jako record. Fajn.

                          _____ Dìdìní _____

   Pak  bylo  potøeba,   aby  jeden  record  zdìdil   polo¾ky  jiného.  V
nìjakém  zdrojáku jsem  vidìl vazbu  object(pøedek), tak  jsem ji  zkusil
pou¾ít...

  Type
    typ1=object
           nìjaká_promìnná : byte;
           jiná_promìnná : word;
          end;
    typ2=object(typ1)
           dal¹í_promìnná : string;
          end;

   A  ono  to  funguje,  v  typu2  jsou  obsa¾eny  i  v¹echny  polo¾ky  z
typu1. To je teda ta dìdiènost, príma.

                          _____ Metody _____

   Dal¹í,  co asi  tak uhodí  do oka  pøi prohlí¾ení  OOP zdrojákù,  jsou
hlavièky procedur a funkcí v definici typu. To jsou metody.

  Type
    typ1=object
           abc : integer;
           procedure xyz;
          end;

  Procedure typ1.xyz;
  begin
   write(abc);
  end.

   Tøída  typ1 má  atribut abc  a metodu  xyz. V¹imni  si, èím  se metoda
xyz  li¹í od  obyèejné procedury.  Za prvé,  pøed názvem  má "typ1.".  Za
druhé, uvnitø metody se dá normálnì pracovat s atributy, zde abc.

               _____ Constructor a destructor? _____

   Konstruktor  a  destruktor  jsou  skoro  úplnì  obyèejné  metody.  Jen
místo  procedure se  u  nich pí¹e  constructor,  resp. destructor.  Tøída
mù¾e  mít víc  konstruktorù i  destruktorù. Vìt¹inou  ale mívá  po jednom
a obvykle  se pojmenovávají Init a  Done. Jejich náplní by  mìlo být nìco
jako inicializace  a zru¹ení jedné  instance. Obvykle to jsou  také první
a  poslední vìc,  které ta  instance  za¾ije. V¹echno  pí¹u tak  neurèitì
proto,   ¾e   máme  v   pou¾ití   konstruktorù   a  destruktorù   spoustu
volnosti (na  rozdíl od C++,  kde se  samy zavolají automaticky  IHNED po
vzniku  instance  a A®  pøi  destrukci  instance).  V pascalu  je  mù¾eme
volat podle  libosti tøeba osmkrát za  sebou nebo ani jednou,  ale jak u¾
jsem psal,  obvykle se  volají jen  jednou a  to na  zaèátku a  na konci.
Navíc platí,  ¾e pokud má  tøída virtuální  metody, nelze je  volat døíve
ne¾ konstruktor.

                           _____ Fail _____

   Dal¹í  zvlá¹tností  je pøíkaz  Fail,  který  lze pou¾ít  pouze  uvnitø
konstruktoru.  Tenhle odstaveèek  by  mìl  být a¾  nìkde  u dna  stránky,
proto¾e Fail  není tak dùle¾itý,  ale kvùli New a  Dispose bys o  nìm mìl
vìdìt.
   Konstruktor  se zvenèí  tváøí  jako funkce,  vrací  true pokud  uspìl,
false   pokud  neuspìl.   Ale  zevnitø   vypadá  jako   procedura,  nelze
nastavit result.  Jediným zpùsobem jak  ohlásit neúspìch je  pøíkaz Fail,
který   konstruktor   zároveò    ukonèí   (exitne).   Pokud   konstruktor
probìhne bez failu, skonèí úspìchem.

                      _____ New a Dispose _____

   Dosud  to  vypadalo  tak,  ¾e  konstruktor  a  destruktor  jsou  úplnì
obyèejné  metody.  Jedna z  jejich  odli¹ností  se  ale mù¾e  projevit  u
pøíkazù New a Dispose. Mìjme tøídu a její instance

  Type
    typ1=object
           abc : integer;
           constructor init;
           procedure xyz;
           destructor done;
          end;
  Var
     a:typ1;
     p:^typ1;

   Po   spu¹tìní   programu   je   a   neinicializovaná   instance  a   p
neinicializovaný pointer  na instanci.  a mù¾eme  jednodu¹e inicializovat
pøíkazem  a.init;.  Pro inicializaci  p  existuje nìkolik  ekvivalentních
variant:

    1) new(p); if p<>nil then if not p.init then dispose(p);
    2) new(p,init);                - new se chová jako procedura
    3) p:=new(^typ1,init);         - new se chová jako funkce : ^typ1

   Máme  tedy  roz¹íøený pøíkaz  new.  Jeho  druhým parametrem  ale  musí
být  konstruktor,  ¾ádná  jiná   metoda.  Analogicky  existuje  roz¹íøený
dispose, ve kterém lze zadat pouze destruktor.

    1) p.done; dispose(p);
    2) dispose(p,done);

                      _____ Inherited, Self _____

   Obèas  se nìkde  objeví slùvka  jako self  nebo inherited.  Vyskytovat
se  mohou   pouze  v  metodách.   Self  je  instance  se   kterou  metoda
pracuje.
   Pøedek   a  potomek   mohou  mít   stejnì  nazvanou   metodu,  to   je
korektní. Kdy¾  potomek provede  pøíkaz xyz;, volá  se jeho  xyz. Zavolat
xyz pøedka lze pøíkazem inherited xyz;.

                          _____ Virtual _____

   Pro  jistotu lehce  zopáknu nìco  z  minulého èlánku.  Máme p  pointer
na  instanci typu  xxx, ale  ten ukazuje  na instanci  typu yyy  (kde yyy
je  potomek  xxx).  Kdy¾  zavoláme  nìjakou  metodu,  provede  se  metoda
tøídy xxx  nebo yyy? U  statických metod  xxx, u virtuálních  yyy. Neboli
u statických rozhoduje typ pointeru, u virtuálních typ instance.
   A  teï  u¾  syntaxe:  pokud  za  deklarací  metody  uvedeme  virtual;,
bude  virtuální, v  opaèném pøípadì  zùstane statická.  Pokud má  potomek
stejnì  nazvanou  metodu  jako  pøedek, musí  zachovat  její  statiènost,
resp. virtuálnost.

                      _____ Private, public _____

   Zapouzdøení  znamená,  ¾e  v¹echno   potøebné  pro  práci  tøídy  bude
zahrnuto v  ní. Na  povrchu bude  vidìt jen  to co  nás zajímá  z pohledu
u¾ivatele  objektu   (metody  udìlej_tohle,  udìlej_tamto).   Uvnitø  asi
budou dal¹í  dùle¾ité metody a  atributy, ale ty u¾  u¾ivatele nezajímají
a  ani  by  o nich  nemìl  vìdìt.  Proto  lze  ka¾dému atributu  a  ka¾dé
metodì  øíct jestli  je privátní  nebo veøejná.  Nejjednodu¹¹í vysvìtlení
bude pøíklad:

  Type
    typ1=object
           abc : integer;
          private:
           efg : string;
           hij : byte;
          public:
           constructor init;
           procedure xyz;
          private:
           destructor done;
          end;

   To co  je za private: je  privátní, to za public: je  veøejné. Polo¾ky
pøed prvním private nebo public jsou public.
   Co  pøesnì  ta  veøejnost  znamená?  ®e  k  polo¾ce  mù¾e  pøistupovat
kdokoliv  a kdekoliv.  Naproti  tomu k  private  polo¾ce lze  pøistupovat
pouze  uvnitø metod  dané tøídy  a uvnitø  metod jejích  potomkù v  tém¾e
modulu  (unitì). Na  jiných místech  "není vidìt",  její pou¾ití  znamená
syntax error (neznámý identifikátor).

   Pozor    na    private.    Inherited   xyz    nevrací    metodu    xyz
bezprostøedního  pøedka,  ale  nejbli¾¹í   public  xyz.  Kdy¾  má  pøedek
private xyz a prapøedek public xyz, inherited vrací prapøedka.

                          _____ Chyby _____

   Na¹el  jsem jednu.  Pokud má  tøída dva  konstruktory a  z jednoho  se
volá  druhý, a  pokud má  potomka, ten  se nesprávnì  inicializuje. Uvedu
pøíklad.

  Type
    typ1=object
           constructor init1;   {inicializace...}
           constructor init2;   {obsahuje volání init1}
          end;

  Type
    typ2=object(typ1)
           constructor init1;   {obsahuje volání inherited init1}
           constructor init2;   {obsahuje volání inherited init2}
          end;

   New(typ2,init1) vrací  správnì objekt  typu typ2,  ale new(typ2,init2)
vrací  hybrid tvaru  a velikosti  typ2 ale  s tabulkou  virtuálních metod
tøídy typ1.

                   _____ TCollection, TStream _____

   K  èemu  v¹echna  ta  teorie..  hrr  do  praxe.  Ohromnì  (giganticky,
kolosálnì)  u¾iteènými se  ukazují tøídy  TCollection a  TStream dodávané
s  Borland  Pascalem  (jsou  v unitì  objects).  TCollection  pøedstavuje
kolekci  "objektù"  stejného  typu  (tøeba bajtù,  tøeba  stringù,  tøeba
buttonù..).  Do kolekce  lze  pøidávat,  odmazávat, vyhledávat,  provádìt
libovolné akce  na v¹echny prvky... K  prvkùm je pøímý pøístup  pøes pole
pointerù.  TStream  pøedstavuje proud  dat,  ze  kterého lze  èíst,  psát
do nìj, seekovat v nìm.

                           _____ C++ _____

   Vá¾nì se nechce¹ nauèit rad¹i C++? :)

</PRE>
<p>
<a href="../dee">Dee</a>
</BODY>
</HTML>
