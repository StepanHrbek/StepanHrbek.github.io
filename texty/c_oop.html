<!DOCTYPE HTML>
<HTML lang="cs">
<HEAD>
 <META charset="iso-8859-2">
 <TITLE>Objektovì Orientované Programování</TITLE>
</HEAD>
<BODY>
<PRE>
                  Objektovì Orientované Programování

   Tenhle  èlánek je  reakcí na  dotazy, které  jsem dostal  ohlednì CiA.
Pokusím se  objasnit co to  je OOP  a co si  o nìm myslím.  Zároveò musím
pøedem  upozornit ty,  kteøí tomu  trochu  rozumí, ¾e  jsem nikdy  ¾ádnou
knihu o  OOP neèetl,  v èlánku  vycházím pouze  z vlastních  zku¹eností a
dal¹ích nedùvìryhodných zdrojù.

Moje (a pøedpokládám i mnohého z vás) první zku¹enost:
   Pár èlánkù  o OOP jsem  pøeci jen vidìl a  vy asi také.  Dozvìdìl jsem
se  z nich  co  je  to zapouzdøení,  dìdiènost  a  polymorfismus. Ale  to
hlavní, k  èemu mi  to bude,  to mi v¾dycky  nìjak unikalo.  Na pøilo¾ené
pøíklady  jsem okam¾itì  vidìl  efektivnìj¹í  neobjektovou alternativu  a
to  mi staèilo  jako dùkaz  nepou¾itelnosti OOP.  Kromì toho  jsem vìdìl,
jak   gigantické   bývají   OO  (objektovì   orientované)   programy   ve
srovnání se  stejnì velkými  neobjektovými a  myslel jsem  si, ¾e  jsou i
pomalej¹í.

   Po  pár letech  praxe  je to  docela  jasné. S  OOP  lze napsat  velmi
pìkné  "kusy  kódu",   které  jdou  pozdìji  snadno   upotøebit  v  mnoha
dal¹ích  programech. Pøedpokladem  opakovaného  pou¾ívání  je ale  jejich
univerzálnost. Kdy¾ se  pak pou¾ijí  na jednodu¹¹í problémy,  které tolik
univerzálnosti  a  dal¹ích  schopností nevy¾adují,  výsledný  program  je
vìt¹í a  nìkdy i pomalej¹í. Zápory  ale vyva¾uje  snadnost s jakou  se OO
programy pí¹í.

   Pozorný  ètenáø mù¾e  namítnout,  ¾e  OO programy  se  pí¹í snadno  a¾
tehdy,   kdy¾   má   programátor  pøipravenou   zásobu   takových   "kusù
kódu",  ze  kterých  se  dá výsledný  program  sestavit.  Ano,  nezbytným
pøedpokladem  snadného   a  rychlého   programování  je  mít   za  základ
nìjakou knihovnu, a» u¾ vlastní nebo cizí, a dobøe se v ní vyznat.

Co to vlastnì to OOP je?
   Je   to  roz¹íøení   jazyka,   které  umo¾òuje   psát  pøesnì   takové
snadno upotøebitelné  univerzální "kusy  kódu" o jakých  tu byla  øeè. Ty
jsou  ale,  kdy¾  to  pøe¾enu,  napsány normálním  jazykem,  OOP  je  jen
"obaluje"  a vná¹í  do programu  strukturu a  poøádek. Tak¾e  OOP je  jen
pomùcka, to hlavní se musí napsat postaru.
   OOP  ale není  ¾ádná kouzelná  hùlka, která  za nás  v programu  udìlá
poøádek.  Syntaxe sice  nutí  k  urèitým krokùm  správným  smìrem, ale  i
tak  nezabrání  øadì  "o¹klivých"  vìcí,   které  se  stále  dají  dìlat.
Dùle¾ité  je myslet  dopøedu a  psát tak,  aby se  dal jednou  hotový kód
pou¾ít i pozdìji a jinde.
   Ale teï  stop. O  OOP pí¹u  jako o nadstavbì  nad nìjakým  jazykem. Ve
skuteènosti asi nejprve  vznikly èistì OOP jazyky (tøeba  SmallTalk) a a¾
po  jejich   úspìchu  nadstavby  nad  zavedené   neobjektové  jazyky  (C,
Pascal).

                                PRINCIPY

   To  byly  rysy OOP,  které  pova¾uji  za  nezbytnì nutné  k  pochopení
významu  a k  úspì¹nému vyu¾ití  OOP.  Tady jsem  chtìl skonèit,  proto¾e
zde  zaèínají  v¹echny ostatní  èlánky  o  OOP a  já  bych  to tak  dobøe
stejnì  napsat   nedokázal.  Ale  pak   mi  pøi¹lo  nefér   teï  skonèit,
následuje  tedy  popis  konkrétních   vlastností,  které  OOP  pou¾ívá  k
dosa¾ení vý¹e popsaných cílù.

   Tøída  je  typ.  Je  to  datová struktura  plus  funkce  pro  práci  s
tìmito daty. Instance je konkétní promìnná typu tøída.

Zapouzdøení je  vlastnost tøíd  a jejich instancí.  To jsou  jakési black
boxy, do  kterých zvenku není  vidìt. Øekne¹  instanci aby provedla  to a
to a  ona to udìlá.  Nezajímá tì jak to  dokázala. Sice tam  nìkde uvnitø
je kód,  který jsi kdysi  musel ty, nebo nìkdo  jiný, napsat, ale  teï se
na vìc  dívá¹ zvenèí a vidí¹  jen povrch black boxu  s nìkolika knoflíky,
kterými  vydává¹ povely.  Praktický význam  je ten,  ¾e a¾  ti schopnosti
tøídy nebudou  staèit, mù¾es  její vnitøek  totálnì pøepsat,  navenek ale
zùstane stejná, tak¾e ve zbytku programu se nebude muset nic mìnit.

Dìdiènost  je vlastnost  tøíd.  Tøída  mù¾e být  potomkem  jedné èi  více
jiných  tøíd  (v pascalu  jen  jedné).  V  takovém pøípadì  zdìdí  datové
struktury a funkce svých pøedkù. To se samozøejmì náramnì hodí.

Polymorfismus  je   vlastnost  instancí.  Instance  rùzných   tøíd  mohou
zvenèí  vypadat  úplnì  stejnì,   uvnitø  ale  pracovat  jinak.  Typickým
pøíkladem  je funkce  "zru¹ se".  Tu mají  skoro v¹echny  tøídy a  tedy i
jejich  instance. Instance  rùzných tøíd  ale vypadují  jinak a  proto se
musí  i ru¹it  jinak.  Polymorfismus  zajistí, ¾e  se  pøi vydání  povelu
provede správná akce v závislosti na tom o jakou instanci jde.

                              IMPLEMENTACE

   A u¾  jsem chtìl  zase skonèit, ale  pøi¹lo mi nefér  vùèi tìm,  co se
prokousali  a¾   sem,  neøíct   nìco  konkrétního  o   implementaci  vý¹e
uvedených  principù. Kdo  chce programovat  OO, musí  znát principy,  ale
taky musí  vìdìt "co  se tam  dìje", tedy  jak jsou  implementovány. Budu
se dr¾et v obecnosti, ¾ádná konkrétní syntaxe.

   Jak u¾  bylo øeèeno  vý¹e, tøída se  skládá z dat  a funkcí  pro práci
s  nimi. Datùm  se øíká  atributy,  funkcím metody.  Kdy¾ zavolá¹  metodu
nìjaké  instance,  je   to  jako  kdybys  zavolal   obyèejnou  funkci  se
skrytým parametrem "pointer na instanci".

   Jak   funguje  zapouzdøení?   V  deklaraci   tøídy   se  uvádí   které
atributy  a metody  jsou veøejné  a které  jsou privátní,  pøípadnì dal¹í
stupnì  veøejnosti/neveøejnosti.  Pouze  s veøejnými  slo¾kami  tøídy  se
pak dá  zvenèí manipulovat. To  ostatní je soukromou zále¾itostí  tøídy a
nikomu  venku  do  toho  nic  není. V  nìkterých  jazycích  jsou  v¹echny
atributy privátní.

   Jak  funguje  dìdiènost?  Instance  je  slo¾ená z  atributù  a  metod.
Dvì  instance stejné  tøídy  mají  v atributech  rùzná  data, ale  jejich
metody  jsou  stejné,  tak¾e  kdy¾  vytvoøí¹  instanci,  pouze  se  nìkde
naalokuje  kus  pamìti  pro  atributy.  Tøída,  která  je  potomkem  jiné
tøídy, zdìdí  její atributy  a metody.  V praxi to  znamená pouze  to, ¾e
se  ka¾dá  instance zvìt¹í  o  zdìdìné  atributy.  Dìdìné metody  jsou  v
pamìti jen jednou, spoleèné pro pøedka i potomka.

   Jak   funguje   polymorfismus?   Nejprve   je  tøeba   vyøídit   jednu
technickou  zále¾itost.  Ka¾dá promìnná  má  svùj  typ. Promìnná  P  mù¾e
být  tøeba pointer  na instanci  tøídy T1.  Ale pøitom  mù¾e ukazovat  na
instanci  tøídy T2,  která  je potomkem  T1. Taková  situace  je bì¾ná  a
naprosto  legální, v¹echno  co  lze provést  s  T1 lze  provést  i s  T2,
tak¾e  mù¾eme  být  bez  obav.   Pøijdeme  pouze  o  mo¾nost  pracovat  s
atributy  a  metodami,   které  má  T2  navíc  oproti   T1.  Ale  vlastnì
nepøijdeme!  Skoro   ka¾dá  instance  toti¾  má   skrytý  atribut,  který
udává její  SKUTEÈNÝ typ, její  tøídu. Metody se  pak dìlí na  statické a
virtuální,  pøièem¾  o  tom  co  se zavolá  pøi  volání  statické  metody
rozhoduje  typ  promìnné, u  virtuálních  metod  rozhoduje typ  instance.
A¾  budeme   chtít  zru¹it  instanci,   na  kterou  ukazuje   pointer  P,
zavoláme  její metodu  "zru¹ se".  Pokud  by byla  statická, zavolala  by
"zru¹ se"  tøídy T1 a zru¹ila  pouze èást instance. Jeliko¾  je to metoda
virtuální,  podívá  se  na  skuteèný  typ instance  a  zavolá  "zru¹  se"
tøídy T2.  Pomocí virtuálních  metod tak mù¾eme  vyu¾ít i  vlastnosti T2,
kterými se li¹í od T1.

Slovníèek s dal¹ími pojmy:
   Constructor   a   destructor   jsou   speciální  metody   volané   pøi
vytváøení  a ru¹ení  instance.  V  C++ se  volají  automaticky, v  Object
Pascalu ruènì.
   Late  binding  je  rozhodování se  jakou  metodu  zavolat a¾  za  bìhu
programu. Tedy zji¹tìní typu instance a zavolání metody toho typu.
   VMT  aneb Tabulka  virtuálních metod  obsahuje  pointery na  virtuální
metody  dané tøídy.  Pointery  se tedy  neskladují  uvnitø instance,  tam
je  pouze  odkaz  na  tabulku   virtuálních  metod  spoleènou  pro  celou
tøídu.  Tento odkaz  je  zároveò oním  skrytým  atributem typu  instance.
Samozøejmì  to  mù¾e být  implementováno  i  jinak,  ale nevím  o  ¾ádném
jazyce, který by tak èinil.

                                 SYNTAXE

   Na  konec by  to  chtìlo  vysvìtlit syntaxi.  Ale  to  by bylo  trochu
del¹í povídání.  Já vím, je to  nefér takhle skonèit, ale  popisù syntaxe
najdete spoustu v pøíslu¹ných knihách a manuálech.

                                ZÁVÌREM

   Pøed  pár  lety  bylo  v¹echno   je¹tì  v  plenkách,  èlovìk  se  mohl
podívat na  jakýkoliv program a  øíct si,  udìlám lep¹í. To  byla paneèku
motivace.  Za  tu  dobu  se  ale  úroveò  dost  zvedla,  u¾  není  snadné
trumfnout   profesionální   programy   nebo   finská   dema.   Zaèínající
programátoøi  tak pøi¹li  o jeden  dùvod proè  programovat, dostat  se na
¹pièku trvá roky  a dá to spoustu práce.  Ale zas to stojí za  to... :) A
beztak je to skvìlá zábava, a» u¾ nahoøe nebo dole. No nic.
   Kdo teï  chce zaèít, asi po¹ilhává  po OOP (pokud doèetl  a¾ sem). Ok,
ale OOP je jen pomùcka. Co vlastnì musí dobrý programátor umìt?

 - schopnost nacházet efektivní øe¹ení problemù
 - pøístup k technickým informacím
 - základní syntaxe jazyka

 - pøidaná OOP syntaxe (pokud nejde o èistì OOP jazyk)
 - principy OOP (které jsem se sna¾il dostat do tohoto èlánku)


Poznámka k terminologii:
   Tøídám  se nìkdy  øíká objekty.  Instancím  se nìkdy  øíká objekty.  A
tak dál, zále¾í na okolnostech.

</PRE>
<p>
<a href="../dee">Dee</a>
</BODY>
</HTML>
